import numpy as np
from random import random
from matplotlib import pyplot as plt


angles = [0.15574770767873, 0.23860518589552004, 0.11423367108136766,
          0.16022748815506072, 0.19184033180688365, 0.07933345614757283,
          0.005912231543530019, 0.09677903577994908, 0.10604705859501715,
          0.035936904576201564, 0.08430254954350393, 0.016371779602801194,
          0.11704172695513196, 0.11847562852572667, 0.05593435857632002,
          0.0677403910208752, 0.07351385221525748, 0.07820905446768807,
          0.09236066928911502, 0.050377814188132766, 0.11261238843463338,
          0.05753214683843999, 0.06432475795651499, 0.04733933525392894,
          0.03810061813844657, 0.05269524048863978, 0.05823083368721373,
          0.053277783269359266, 0.11249368601336386, 0.04495102986817251,
          0.09845305312830273, 0.04362748750263761, 0.07565988825236801,
          0.013645006221554574, 0.04241117915476075, 0.05156976648786049,
          0.02777186617550082, 0.031055040776932094, 0.05711408433104505,
          0.03620254687965533, 0.046832595058099565, 0.03456669699336816,
          0.0319708895072758, 0.06212188022976961, 0.013146778143020439,
          0.07059282029300064, 0.029541625706444117, 0.03801264947284569,
          0.015844625049923036, 0.048236643095001225]


def monte_carlo(a: list[list], b: list, N: int, m: int) -> list:
    h = list(map(list, list(np.identity(3))))
    pi = [1 / 3, 1 / 3, 1 / 3]
    p = [[1 / 3, 1 / 3, 1 / 3],
         [1 / 3, 1 / 3, 1 / 3],
         [1 / 3, 1 / 3, 1 / 3]]
    res = 3 * [0]

    for i in range(3):
        chain = (N + 1) * [0]
        Q = (N + 1) * [0]
        ksi = m * [0]
        for j in range(m):
            for k in range(N + 1):
                r = random()
                if r < pi[0]:
                    chain[k] = 0
                elif r < pi[0] + pi[1]:
                    chain[k] = 1
                else:
                    chain[k] = 2
            if pi[chain[0]] > 0:
                Q[0] = h[i][chain[0]] / pi[chain[0]]
            else:
                Q[0] = 0
            for k in range(1, N + 1):
                if p[chain[k - 1]][chain[k]] > 0:
                    Q[k] = Q[k - 1] * a[chain[k - 1]][chain[k]] / p[chain[k - 1]][chain[k]]
                else:
                    Q[k] = 0
            for k in range(N + 1):
                ksi[j] += Q[k] * b[chain[k]]
        for k in range(m):
            res[i] += ksi[k]
        res[i] /= m

    return res


def check_exact(A: list[list], b: list) -> list:
    return np.linalg.inv(A).dot(b)


def count():
    x = check_exact([[1.2, 0.5, 0.3], [-0.4, 1.2, 0.1], [0.3, -0.1, 1.2]], [4, 1, -1])
    x /= np.linalg.norm(x)
    res = []
    for i in range(10, 501, 10):
        temp = monte_carlo([[-0.2, -0.5, -0.3], [0.4, -0.2, -0.1],
                            [-0.3, 0.1, -0.2]], [4, 1, -1], i, i * 10)
        temp /= np.linalg.norm(temp)
        dot = np.dot(x, temp)
        res.append(np.arccos(dot))
    return res


def main():
    x = check_exact([[1.2, 0.5, 0.3], [-0.4, 1.2, 0.1], [0.3, -0.1, 1.2]], [4, 1, -1])
    print(x)
    res = monte_carlo([[-0.2, -0.5, -0.3], [0.4, -0.2, -0.1], [-0.3, 0.1, -0.2]], [4, 1, -1], 1000, 10000)
    print(res)
    plt.plot(list(range(10, 501, 10)), angles)
    plt.ylabel("angles")
    plt.show()


if __name__ == "__main__":
    main()